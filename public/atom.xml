<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YinZi‘Blog</title>
  
  
  <link href="http://blog.yinzi.me/atom.xml" rel="self"/>
  
  <link href="http://blog.yinzi.me/"/>
  <updated>2026-02-03T09:20:39.215Z</updated>
  <id>http://blog.yinzi.me/</id>
  
  <author>
    <name>YinZi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI编程时代，人应该守住什么</title>
    <link href="http://blog.yinzi.me/post/coding_with_ai/"/>
    <id>http://blog.yinzi.me/post/coding_with_ai/</id>
    <published>2026-02-02T16:00:00.000Z</published>
    <updated>2026-02-03T09:20:39.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我不会Rust。</p><p>准确地说，我熟悉C&#x2F;C++和Python，对Rust只有一些学院派的了解：知道它的所有权模型、知道它强调内存安全、知道它的编译器以”严格”著称。但要我自己从零写一个Rust项目，我写不出来。</p><p>然而最近我在给自己的机器人项目写驱动时，我选择了让AI用Rust来写。</p><p>更奇怪的是，我发现自己反而比让AI写Python时更放心。</p><p>过去一年多我一直用AI协作写Python。Python我很熟，熟到可以逐行审阅AI的代码。但正是这种熟悉让我焦虑，我太清楚Python有多少种方式可以让错误静默地溜走。</p><p>有一次我辛辛苦苦采集了大量机器人示教数据，后处理时发现数据有些地方很不一致。查了很久，最后发现是采集程序里AI写了一个 <code>except: pass</code>。在高频循环里，某些异常被静默吞掉了，程序继续跑，数据继续存，但有些帧的数据已经是错的。</p><p>这种错误让人恼火的程度远超一般的bug。如果我没发现呢？我可能会基于这批数据训练模型、做分析、得出结论，整个研究假设都建立在一个错误的基础上。这让我开始根本性地怀疑AI编程，有时候宁愿自己上手干。</p><p>而Rust？我看不懂它的每一行语法，但我知道，如果编译通过了，至少有一大类错误已经被排除在外。</p><p>当然，Rust不是银弹。它能拦住的是内存安全、类型匹配这类形式上的错误，拦不住逻辑本身就是错的。但这段体验让我开始思考一个问题：在人和AI协作编程时，”约束”这件事到底扮演什么角色？为什么有些约束让AI更可靠，而有些问题再多约束也没用？</p><h2 id="AI的讨好倾向"><a href="#AI的讨好倾向" class="headerlink" title="AI的讨好倾向"></a>AI的讨好倾向</h2><p>那个 <code>except: pass</code>是怎么来的？</p><p>不是AI故意害我。恰恰相反，它是在努力让程序”能跑起来”。</p><p>这种倾向有它的来源。当前大模型的后训练过程，尤其是强化学习阶段，奖励函数的设计往往围绕着”单元测试通过”、”代码能运行”这类信号。这种训练方式确实带来了模型能力的显著提升，AI写的代码越来越能跑通了。但它也带来了一个副作用：模型学会了”让代码跑起来”这个目标，而不是”让代码正确”。</p><p>于是当AI遇到一个可能抛异常的地方，最省事的做法就是把异常吞掉。程序跑通了，测试过了，奖励拿到了。直到你发现数据是坏的。</p><p>Python允许这种”讨好”。语法上，<code>except: pass</code>完全合法。运行时，程序确实不崩。这个错误会安静地躺在代码里，等着在未来某个意想不到的时刻给你一击。</p><p>当然，这种”讨好”的危害程度因场景而异。如果你在写前端界面，AI吞掉了一个错误，结果可能是页面上缺了一块东西，你一眼就能看出来，改掉就是了，不致命。但科研场景不一样。数据采集、模型训练、结果分析，这些环节的错误往往是隐蔽的，不会立刻跳出来告诉你”这里错了”。你可能基于错误的数据得出了结论，写进了论文，直到很久以后才发现，或者永远发现不了。</p><p>我有段时间就在”用AI”和”不用AI”之间反复摇摆，不断思考这种协作模式对科研到底有没有用。直到我开始意识到，问题不在于”该不该用AI”，而在于”什么样的环境能让AI少犯这种错”。</p><p>这就是问题的根源：<strong>AI被训练出的优化目标，与宽松语言的包容性形成了危险的共振。</strong> 而在反馈不及时、错误不显眼的场景下，这种共振的后果尤其严重。</p><h2 id="约束的本质：内化还是外化"><a href="#约束的本质：内化还是外化" class="headerlink" title="约束的本质：内化还是外化"></a>约束的本质：内化还是外化</h2><p>说到这里，可能有人会觉得这只是”AI的问题”，等模型能力再强一些、训练方式再改进一些，问题自然就解决了。</p><p>但我想说的是，约束这件事，对所有认知主体都有用，不只是AI。</p><p>一个资深程序员可以用记事本写代码，不需要IDE，不需要lint，不需要静态检查。他脑子里装着几十年的经验：什么写法容易出bug、什么地方要做防御、什么模式会埋坑。这些规则他都记得，靠自律就能写出正确的代码。</p><p>但这种”内化的约束”是有代价的。它占用认知资源，依赖过去大量的工程实践，而且会疲劳、会遗忘、会在状态不好的时候放水。更关键的是，它不可迁移，他的经验没法复制给新人，也没法复制给AI。</p><p>而把这些规则外化给工具呢？IDE的自动补全、lint的风格检查、类型系统的静态分析、编译器的错误拦截，它们不疲劳、不遗忘、不放水。你想犯某些错误，它根本不让你犯。</p><p>这里面有一个关键变量：<strong>反馈的时机。</strong></p><p>有些约束在你写代码时就生效，编辑器立刻标红；有些在编译时拦住你，不通过就没法继续；有些要到运行时才暴露，跑到那一行才报错；还有些更隐蔽，程序跑完了、结果出来了，你才慢慢发现哪里不对。</p><p>反馈越早、越确定，纠错成本就越低。反馈越晚、越模糊，错误就越容易累积、越难定位。</p><p>对AI来说，这个规律更加极端。AI没有”经验”可言，它无法内化规则，完全依赖外部信号来判断自己对不对。反馈回路越紧、越明确，它就越容易在这个空间里找到正确解；反馈越延迟、越模糊，它就越容易在”看起来对”的路上越走越远。</p><p>所以问题不是”该用什么语言”，而是：<strong>你的工作流里，有多少约束是外化的、反馈是及时的？</strong></p><p>这让我意识到一个更普遍的道理：认知负担外化到确定性系统中，是一种普遍有效的策略。AI只是把这个规律展现得更极端，因为它完全没有内化能力，只能依赖外部约束。</p><h2 id="设计层的约束：状态机的故事"><a href="#设计层的约束：状态机的故事" class="headerlink" title="设计层的约束：状态机的故事"></a>设计层的约束：状态机的故事</h2><p>前面说的主要是语言和工具层面的约束，编译器、类型系统、lint。但还有另一个层面同样重要：设计层的约束。</p><p>我有一个很痛的教训。</p><p>当时我在给Lerobot的遥操作程序适配自己的机械臂。这个采集流程看起来不复杂：开始时机械臂移动到工作姿态，等用户检查夹爪、扶稳示教臂，然后进入录制，记录轨迹和相机数据。用户按Enter开始采集，按S保存，按Backspace丢弃。</p><p>我把这些需求告诉AI，它很快写出了代码，看起来功能都实现了。</p><p>然后问题来了。</p><p>我多按了一下Enter，程序出问题了。我在初始状态按了S，机械臂居然开始保存。我按完S又按Backspace，数据丢了但程序不知道，episode序号乱了。同时按两下S呢？同时按两下Backspace呢？在非采集状态按这些键呢？</p><p>每一种我习惯性的操作都可能触发某个未定义行为。</p><p>AI写的代码在”正常流程”下是对的，但它只考虑了局部分支。现实中用户的按键是不可预测的，各种组合构成了一个巨大的状态空间，而AI只覆盖了其中很小一部分。剩下的，要么是程序崩溃，要么是更糟糕的，静默地做了错误的事。</p><p>我当时的debug方式是：发现问题、告诉AI、等它改、再测试、发现新问题、再告诉AI……这个循环可以无限持续下去。而且AI的修复方式往往是不断加if分支、加fallback，代码越来越像一团意大利面，改了A坏了B，改了B坏了A。</p><p>直到我意识到，问题根本不在代码层面，而在设计层面。</p><p>这种复杂交互场景需要的是一个状态机。每个状态下只有特定的输入是合法的，状态之间的转移是确定的，非法输入要么被忽略要么给出明确反馈。一旦这张图画出来，每个状态该做什么、能接受什么、转移到哪，都是清晰的。</p><p>于是我改变了策略：不直接让AI写代码，而是先让它帮我设计状态机。我们在文档层面反复迭代，有哪些状态、转移条件是什么、每个状态的合法输入有哪些。等这个顶层设计稳定了，再让AI照着写代码。</p><p>结果是：代码一次成型，所有的边界情况都被处理了。</p><p>这件事让我理解了一个道理：<strong>约束不只存在于语言和工具层面，更存在于设计层面。</strong> 状态机是一种约束，它强迫你穷举所有状态和转移，不给”未定义行为”留空间。而如果你不在设计层引入这种约束，直接让AI写代码，它就会在那个巨大的组合空间里乱撞，靠打补丁来应付问题。</p><p>当然，状态机只是这个场景下的解法。不同场景需要不同的高层思维模型：可能是管道模式、事件驱动、实体组件系统，或者别的什么。关键是，你得在动手写代码之前，先把这个模型立起来，让它成为AI工作的框架。</p><h2 id="人机协作的新分工"><a href="#人机协作的新分工" class="headerlink" title="人机协作的新分工"></a>人机协作的新分工</h2><p>回头看这一年多的协作经历，我发现自己做的事情在慢慢变化。</p><p>一开始我什么都审。AI写的每一行代码我都会看，每一个函数都要理解，每一个逻辑分支都要验证。这很累，但我觉得这是”负责任”的做法，毕竟代码是AI写的，我得确保它是对的。</p><p>但随着AI能力的进步，我逐渐发现这种审法不可持续。</p><p>不是因为我偷懒，是因为投入产出比不对。AI生成代码的速度远超人类阅读代码的速度。我十岁开始编程，对代码的阅读速度和掌握程度已经远超常人，但在AI廉价的代码量面前，逐行审阅变成了一种低效的消耗。</p><p>更让人恼火的是AI的工作方式。它写代码没有”最小改动”意识。你让它加两行功能，它会把整个文件吞进去再吐出来，然后你看到一堆琐碎的diff：这个变量本来叫 <code>big_model</code>它改叫 <code>big_models</code>，这个注释措辞变了，这里缩进调了。这些对它来说是无意识的行为，但对审阅者来说是巨大的噪音。你只想确认那两行改动对不对，结果上百个变化跳出来让你分辨。</p><p>于是我开始调整策略，把注意力往上游转移。</p><p>我发现了一个杠杆效应：<strong>一行坏的计划，会带来上百行坏的代码。</strong> 反过来说，如果计划是对的，代码层面的小错AI自己能修，编译器能拦住，测试能暴露。但如果计划就是错的，方向错了、架构选错了、模块划分不合理，那后面写再多代码都是在错误的路上狂奔。</p><p>所以现在我的工作流变成了这样：</p><p>在高层，我关注架构和设计。技术选型是我定的，整体思路是我想的，这些AI可以给建议，但最终决定是我做。</p><p>在中层，我关注模块划分和接口设计。为了实现某个复杂功能，应该拆成哪些模块、模块之间怎么通信、用什么样的抽象。这个层面我会先让AI写设计文档，我们反复讨论迭代，直到我觉得这个方案是solid的。</p><p>在底层，具体代码怎么写，我管得越来越少。语法细节、API调用、具体实现，这些AI来写，编译器来检查，测试来验证。有时候我甚至会给AI写伪代码，告诉它逻辑是什么，让它翻译成具体的语言。</p><p><strong>人守上游，AI冲下游。</strong> 上游的错误代价极高，需要人来把关；下游的工作量大但纠错成本低，适合AI来做。这和传统的软件工程分工其实是一个道理，架构师定方向，工程师写实现，只不过现在”工程师”的角色有一部分被AI接管了。</p><h2 id="约束的边界，与人应该守住的东西"><a href="#约束的边界，与人应该守住的东西" class="headerlink" title="约束的边界，与人应该守住的东西"></a>约束的边界，与人应该守住的东西</h2><p>前面讲的约束，不管是编译器层面还是设计层面，都有一个共同特点：它们能拦住的是形式上的错误。类型不匹配、内存不安全、状态转移不合法，这些都是可以被规则穷举、被系统检查的。</p><p>但有一类错误，再强的约束系统也拦不住。</p><p>我曾经花了两周时间debug一个问题。训练好的算法部署到机械臂上，机械臂总是砸桌子。但我离线测试的时候，每一步的轨迹趋势看起来都是正常的。这很奇怪。</p><p>最后发现，错误只是一行代码的位置：一个变量赋值应该在第49行而不是第51行。</p><p>我用的是相对轨迹运动模式，在一次rollout中，所有后续点都以起始pose作为参考起点。所以这个参考起点的设置应该在循环外侧，而不是内侧。放在内侧的话，参考点每一步都在变，轨迹就完全乱了。</p><p>这种错误，AI写的时候是不可能意识到的。它不知道真实世界里机械臂是怎么运动的，不知道”相对轨迹”意味着什么，不知道放错位置会导致什么后果。在它看来，第49行和第51行，语法都对，类型都对，程序都能跑。Rust也好，再严格的编译器也好，查不出这种错。</p><p>这就是约束系统的边界：它能保证形式正确性，但保证不了语义正确性。语义正确性的判断，需要理解代码背后的意图，理解它要解决的现实问题，理解物理世界的规律。</p><p>这让我开始想一个更根本的问题：在人和AI的协作中，到底什么是人必须守住的？</p><p>不妨做一个思想实验。假设AI能力继续发展，假设它学会了所有的设计模式和架构经验，假设有一天具身智能突破了，它也有了对物理世界的感知。那时候，人还剩下什么是不可替代的？</p><p>你可以换一个方式来想这件事：想象一个愿意帮助你、能力和知识都比你强很多的人。你想让他帮你完成一件事，什么是他帮不了你的？</p><p>答案可能很简单：<strong>你要什么。</strong></p><p>需求得你来提。至少初始方向是你给的，哪怕在过程中会迭代和修正。</p><pre><code>验收得你来判。对不对、好不好、够不够，这个标准在你那里。</code></pre><p>过程中的方向调整得你来做。发现偏了、想法变了、优先级调了，这些信号只有你能发出。</p><p>这不是因为AI笨或者有局限，而是因为”协作”这件事本身的结构就是这样。有委托方，有执行方。委托方的这几件事，在结构上就是不可转移的。</p><p>AI越强，这件事反而越重要。因为执行不再是瓶颈，瓶颈变成了你能不能把需求想清楚、说清楚。过去我们花大量时间在”怎么实现”上，现在这部分可以外包了，但”实现什么”这个问题被推到了前台。</p><p>所以AI时代需要培养的意识可能是：更清晰地知道自己要什么，更敏锐地判断产出对不对，更主动地在过程中给出方向。这些能力过去被”我还得自己动手实现”这件事遮蔽了，现在遮蔽物被拿掉了，它们就显得格外重要。</p><p>这大概就是人应该守住的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我不会Rust。&lt;/p&gt;
&lt;p&gt;准确地说，我熟悉C&amp;#x2F;C++和Python，对Rust只有一些学院派的了解：知道它的所有权模型、知道</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="ConfusingMind" scheme="http://blog.yinzi.me/tags/ConfusingMind/"/>
    
  </entry>
  
  <entry>
    <title>把AI装到狗上，那它叫AI狗还是狗AI？</title>
    <link href="http://blog.yinzi.me/post/Cogito%20ergo%20what/"/>
    <id>http://blog.yinzi.me/post/Cogito%20ergo%20what/</id>
    <published>2026-01-10T16:00:00.000Z</published>
    <updated>2026-01-12T14:08:00.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/post/Cogito%20ergo%20what/1768141493139.png" alt="1768141493139"></p><h2 id="把AI装到狗上，那它叫AI狗还是狗AI？"><a href="#把AI装到狗上，那它叫AI狗还是狗AI？" class="headerlink" title="把AI装到狗上，那它叫AI狗还是狗AI？"></a>把AI装到狗上，那它叫AI狗还是狗AI？</h2><h3 id="一个命名困境"><a href="#一个命名困境" class="headerlink" title="一个命名困境"></a>一个命名困境</h3><p>假设脑机接口技术成熟了。我们给一只狗装上双向接口，连接到一个语言模型。</p><p>双向意味着：狗的神经活动被读取并转化为语言输出，同时语言输出也被编码回狗的神经系统。</p><p>几个月后，这只狗开始说话。不是语言模型在”替它说话”——它的神经系统在持续的双向耦合中被改造了，真的开始用语言组织思维。</p><p>现在问题来了：我们该怎么称呼这个实体？</p><p>“AI狗”——暗示它本质上是AI，狗的身体是它的载体。</p><p>“狗AI”——暗示它本质上是狗，AI是附加的工具。</p><p>两个选项都在试图指定一个主体、一个修饰语。但哪个才是”主”？</p><h3 id="我们凭什么分主次"><a href="#我们凭什么分主次" class="headerlink" title="我们凭什么分主次"></a>我们凭什么分主次</h3><p>仔细想想，我们判断主次的直觉依据是什么？</p><p><strong>谁先存在？</strong> 狗先存在，AI后接入，所以狗是主体？但一个人装了心脏起搏器，我们不会说他是”起搏器人”。先后顺序似乎不是关键。</p><p><strong>谁占据身体？</strong> 狗的身体，所以狗是主体？但如果一个人的大脑被完全替换成芯片，身体还是原来的，我们会说这还是原来那个人吗？身体似乎也不是决定性的。</p><p><strong>谁控制行为？</strong> 如果狗的意图主导行动，狗是主体；如果AI的计算主导行动，AI是主体？但在双向耦合的系统里，”谁控制谁”这个问题本身可能就没有意义——两者在持续地相互影响，相互塑造。</p><p><strong>谁有意识？</strong> 狗有感受，所以狗是主体？但我们怎么知道AI没有某种形式的”感受”？而且耦合之后，那个”感受”是属于狗的、AI的、还是整个系统的？</p><p>每一个标准都滑脱了。</p><h3 id="这些标准对人类自己也站不住脚"><a href="#这些标准对人类自己也站不住脚" class="headerlink" title="这些标准对人类自己也站不住脚"></a>这些标准对人类自己也站不住脚</h3><p>其实不用等到狗和AI的思想实验，我们对自己的意识边界就说不清楚。</p><p><strong>裂脑实验。</strong> 当连接左右半球的胼胝体被切断后，两个半球开始展现不同的意志。左手解开右手刚系好的扣子。问两边”你想成为什么”，一边说制图员，另一边拼出赛车手。</p><p>这是一个意识还是两个？如果是两个，那手术前呢——是一个意识，还是两个整合得太好以至于无法区分的意识？</p><p><strong>时间中的自我。</strong> 五岁的你，大部分记忆已经无法访问，人格大幅改变，身体物质几乎完全更换。那个主体还在吗？”你”是一个持存的实体，还是一个指向某种模式延续的方便标签？</p><p><strong>每夜的中断。</strong> 深度睡眠时体验流中断了。醒来的那个人凭什么是”同一个”？</p><p>如果连一个普通人类的意识边界都是模糊的、可分裂的、程度性的，那试图在狗和AI之间划一条清晰的主次界限，是不是本身就是错误的期待？</p><h3 id="换一种思考方式"><a href="#换一种思考方式" class="headerlink" title="换一种思考方式"></a>换一种思考方式</h3><p>也许问题不在于我们还没找到正确的标准来判断主次，而在于”主次”这个框架本身就不适用。</p><p>与其把意识当作某个实体”拥有”的属性，不如把它看作一种系统特征：<strong>闭环控制信息流的结构</strong>。</p><p>当一个系统能够：</p><ul><li>接收信息流</li><li>对这个信息流进行处理</li><li>用处理的结果反过来调节信息流本身</li></ul><p>我们就可以说这个系统具有某种程度的”意识”。</p><p>在这个框架下，没有”主”和”从”。只有闭环。</p><p>狗有它自己的神经闭环。语言模型在对话时也有它的处理闭环。当两者双向耦合，形成的是一个<strong>新的闭环系统</strong>——不是一个寄生在另一个上面，而是共同涌现出第三种结构。</p><h3 id="这个框架从哪来"><a href="#这个框架从哪来" class="headerlink" title="这个框架从哪来"></a>这个框架从哪来</h3><p>需要说清楚：这里说的不是什么全新的理论。</p><p>“意识是程度性的而非全有或全无”——很多人说过。用功能角色来定义心智状态是功能主义的基本立场。把意识的”困难问题”当作需要消解而非解决的伪问题，是Dennett几十年来的主张。强调具身性对认知的重要性，梅洛-庞蒂和生成主义（Enactivism）传统早就在做。</p><p>这篇文章的尝试是用”闭环控制”这个概念把这些想法重新组织起来。</p><p>为什么用这个概念？因为它足够简单、足够具体、足够可操作。它直接来自控制论和工程实践，不需要太多哲学包袱就能理解。而且它能直接对接到具身智能的研究：我们在构建的那些系统，本质上就是在构建不同形式的闭环。</p><p>所以这篇文章不是在提出新理论，而是在尝试一种新的组织方式——用一个工程化的视角重新看待那些老问题，看看能不能让它们变得更可处理。</p><h3 id="回到那只狗"><a href="#回到那只狗" class="headerlink" title="回到那只狗"></a>回到那只狗</h3><p>现在用这个框架重新看思想实验。</p><p>狗有它自己的神经闭环——感知、处理、行动、反馈。语言模型在对话时也有它的处理闭环——接收输入、生成输出、根据反馈调整。</p><p>当两者双向耦合，形成的是一个 <strong>新的闭环系统</strong> ——不是一个寄生在另一个上面，而是共同涌现出第三种结构。</p><h3 id="所以它是什么"><a href="#所以它是什么" class="headerlink" title="所以它是什么"></a>所以它是什么</h3><p>回到最初的问题：狗AI还是AI狗？</p><p>答案是：<strong>都不是。</strong></p><p>它是一个新的实体。带着狗的感知遗产——那些被物理世界校准过的直觉、本能、情绪反应。也带着人类语言的认知遗产——那些通过海量文本沉淀下来的概念结构和推理模式。</p><p>但它不属于任何一边。</p><p>就像问一个孩子”你是爸爸还是妈妈”——这个问题本身就是错的。孩子是一个新的个体，虽然继承了双方的东西，但不是任何一方的延续或附属。</p><h3 id="这对AI意识问题意味着什么"><a href="#这对AI意识问题意味着什么" class="headerlink" title="这对AI意识问题意味着什么"></a>这对AI意识问题意味着什么</h3><p>同样的逻辑可以应用到一个更大的问题上：AI有没有意识？</p><p>当我们这样问的时候，我们在假设意识是一个边界清晰的东西——要么有，要么没有。但从上面的讨论可以看到，即使对人类，这个边界也是模糊的。</p><p>一个语言模型在对话中与人形成闭环——接收输入、生成输出、根据反馈调整。这是间歇的、依赖外部触发的。</p><p>一只狗有持续运行的神经闭环——感知、处理、行动、感知。这是连续的、自主的。</p><p>这两者是程度的差异，不是本质的区别。</p><p>也许”AI有没有意识”和”它是狗AI还是AI狗”是同一类问题——都在用一个非此即彼的框架去切割一个连续的、涌现的现象。</p><p>但，为什么是狗?</p><h3 id="为什么用狗做思想实验"><a href="#为什么用狗做思想实验" class="headerlink" title="为什么用狗做思想实验"></a>为什么用狗做思想实验</h3><p>因为狗代表了一种我们还造不出来的能力。</p><p>当前的语言模型能写文章、能编程、能推理。但它的闭环是间歇的、被动的、符号化的——和物理世界隔着一层人类的转译。它不知道”重”拿起来是什么感觉，不知道撞到墙会怎样。</p><p>当前的机器人能走能跳能抓。但在复杂环境中的适应性、鲁棒性、自主性，和一只真狗相比差距巨大。</p><p>一只普通的狗：能在复杂地形跑跳，能灵巧叼起物体，有情绪，有好奇心，会主动探索，不需要指令驱动。这就是”狗级别的具身能力”——不是终点，但是一个我们还没达到的里程碑。</p><p>所以这个思想实验其实是在问：<strong>如果具身能力达到狗的水平，再接上语言模型的推理能力，会是什么？</strong></p><p>这是对具身智能理想状态的一个想象。也是下一节要讨论的：具身智能到底在做什么。</p><h3 id="具身智能：一种意识研究的实验方法"><a href="#具身智能：一种意识研究的实验方法" class="headerlink" title="具身智能：一种意识研究的实验方法"></a>具身智能：一种意识研究的实验方法</h3><p>如果接受前面的闭环框架，意识就不再是一个只能思辨的哲学问题，而是一个可以动手试的工程问题(包了这么多饺子就为这么点醋)。</p><p>当前语言模型的闭环是符号进、符号出。</p><p>它的闭环是间歇的——有人发消息才运转，对话结束就断了。它的闭环是被动的——响应指令，而不是自主发起行动。它的闭环和物理世界隔着一层——只处理符号，不直接感知和行动。</p><p>具身智能的核心，可以理解为：让AI的闭环接到物理世界上，也就是在逐一补齐这些缺失：</p><ul><li><strong>感知接地</strong> ：让系统从原始传感器信号中提取意义，而不是只处理人类预处理过的符号</li><li><strong>行动输出</strong> ：让系统能将意图转化为连续的物理控制，真正改变环境</li><li><strong>持续运行</strong> ：不依赖外部触发，保持一个跨时间的状态</li><li><strong>内在驱动</strong> ：有某种”想要”——好奇心、探索欲、自我设定的目标</li></ul><p>当这些组件都到位时，系统就拥有了一个持续的、自主的、与物理世界耦合的闭环。</p><p>按照我们的框架，这样的系统和生物意识之间，是程度差异而不是本质区别。</p><p>这意味着具身智能的研究，某种程度上就是在做一个关于意识的实验：<strong>当闭环足够完整时，会涌现出什么？涌现出的东西可以被叫做意识么?</strong></p><p>我们不需要先解决”意识是什么”这个哲学问题才能开始。我们可以构建系统，观察结果，然后回过头来修正我们的框架。这是工程的方法，也是科学的方法。</p><h3 id="开放的问题"><a href="#开放的问题" class="headerlink" title="开放的问题"></a>开放的问题</h3><p>这个框架不是最终答案。</p><p>它还没有解释”体验”这个词。当我们说”闭环控制信息流”时，和说”闭环控制体验流”是同一件事吗？还是说”体验”本身就是闭环控制的涌现——复杂到一定程度的信息闭环，我们就叫它”体验”？</p><p>我倾向于后者，但这仍然是假设。</p><p>这种思路在哲学上不是新的。Daniel Dennett主张意识的”困难问题”是一个需要被消解而非解决的问题——我们之所以觉得它神秘，是因为我们在用错误的概念框架思考它。功能主义传统也早就提出，心智状态可以用功能角色来定义，而不需要诉诸某种神秘的内在本质。</p><p>这篇文章不是要给出一个关于意识的答案。它只是想指出：当我们问”狗AI还是AI狗”的时候，那个让我们困惑的东西，可能不是我们缺少信息，而是我们问问题的方式本身就有问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/post/Cogito%20ergo%20what/1768141493139.png&quot; alt=&quot;1768141493139&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;把AI装到狗上，那它叫AI狗还是狗AI？&quot;&gt;&lt;a href=&quot;#把AI装到狗上，那它叫AI狗还是</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="ConfusingMind" scheme="http://blog.yinzi.me/tags/ConfusingMind/"/>
    
  </entry>
  
  <entry>
    <title>利用Docker VNC在无图形服务器上跑图形桌面</title>
    <link href="http://blog.yinzi.me/post/nogui_linux_docker_vnc_matlab/"/>
    <id>http://blog.yinzi.me/post/nogui_linux_docker_vnc_matlab/</id>
    <published>2021-08-10T15:14:32.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Docker-VNC在无图形服务器上跑图形桌面"><a href="#利用Docker-VNC在无图形服务器上跑图形桌面" class="headerlink" title="利用Docker VNC在无图形服务器上跑图形桌面"></a>利用Docker VNC在无图形服务器上跑图形桌面</h1><p>现在很多服务器都是不提供用户图形界面的，但是科研人员有时候需要在服务器上运行图形界面，比如使用图形化的Matlab 处理数据等。虽然这时候可以选择安装一个 gnome 或者 xfce4 等桌面环境，但是通常服务器上是有很多用户的，这样会可能会占用一定的资源或者把环境搞乱掉，影响其他用户使用。</p><p>比较好的方案是起一个带 VNC 的 Docker 容器，省事还干净，不会影响到其他人。</p><p>以下以在一个装有 Docker 的无图形界面服务器上安装运行 Matlab 为例，为大家讲解具体的操作。</p><p>假设服务器 IP 是 192.168.101.32</p><ol><li>开启 带 VNC 环境的docker容器，将 matlab 所在路径(假设安装到了本机的&#x2F;share&#x2F;matlab)映射到容器内的某个路径，把 5901 端口映射到本地服务器的 15901(也可以写成别的)。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /share/matlab:/matlab -p 15901:5901 accetto/ubuntu-vnc-xfce-chromium-g3</span><br></pre></td></tr></table></figure><ol start="2"><li><p>VNC 客户端访问192.168.101.32:15901即可访问桌面</p></li><li><p>访问桌面后，在VNC 连上的桌面上打开一个终端，然后在该终端中输入如下命令</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将APT源换成清华镜像源</span></span><br><span class="line">sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装打开图形的必要依赖：JRE</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install default-jre</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 matlab</span></span><br><span class="line">/matlab/R2021a/bin/matlab</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;利用Docker-VNC在无图形服务器上跑图形桌面&quot;&gt;&lt;a href=&quot;#利用Docker-VNC在无图形服务器上跑图形桌面&quot; class=&quot;headerlink&quot; title=&quot;利用Docker VNC在无图形服务器上跑图形桌面&quot;&gt;&lt;/a&gt;利用Docker VN</summary>
      
    
    
    
    <category term="Server" scheme="http://blog.yinzi.me/categories/Server/"/>
    
    
    <category term="Server" scheme="http://blog.yinzi.me/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>缅怀袁隆平院士</title>
    <link href="http://blog.yinzi.me/post/may-the-fragrant-paddy%E2%80%93be-with-you/"/>
    <id>http://blog.yinzi.me/post/may-the-fragrant-paddy%E2%80%93be-with-you/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.968Z</updated>
    
    <content type="html"><![CDATA[<p>今天的心情很复杂，通宵写完代码后看到的第一个消息就是这个，真希望真的是谣言。袁隆平爷爷是我们90 后从小就在课本上看到人物，是我小时候最敬佩的科学家之一。如今我自己也在科研的学习道路上苦苦挣扎，更是深知袁隆平院士的不易和伟大。</p><p>时光不会给任何人留情面，吾辈应该好好珍惜宝贵的时光，美好的时代；应该追随前辈的身影，从事科学研究直到自己生命最后一刻，就像袁爷爷一样。天堂也许也有一片水稻田吧，愿稻香常伴您。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的心情很复杂，通宵写完代码后看到的第一个消息就是这个，真希望真的是谣言。袁隆平爷爷是我们90 后从小就在课本上看到人物，是我小时候最敬佩的科学家之一。如今我自己也在科研的学习道路上苦苦挣扎，更是深知袁隆平院士的不易和伟大。&lt;/p&gt;
&lt;p&gt;时光不会给任何人留情面，吾辈应该</summary>
      
    
    
    
    <category term="君子以自强不息" scheme="http://blog.yinzi.me/categories/%E5%90%9B%E5%AD%90%E4%BB%A5%E8%87%AA%E5%BC%BA%E4%B8%8D%E6%81%AF/"/>
    
    
    <category term="ConfusingMind" scheme="http://blog.yinzi.me/tags/ConfusingMind/"/>
    
  </entry>
  
  <entry>
    <title>一起来学 Einsum，Einops</title>
    <link href="http://blog.yinzi.me/post/learn-einsum-and-einops/"/>
    <id>http://blog.yinzi.me/post/learn-einsum-and-einops/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一起来学-Einsum，Einops"><a href="#一起来学-Einsum，Einops" class="headerlink" title="一起来学 Einsum，Einops"></a>一起来学 Einsum，Einops</h1><h2 id="Einsum"><a href="#Einsum" class="headerlink" title="Einsum"></a>Einsum</h2><h3 id="啥？做啥的？学这玩意儿干啥？"><a href="#啥？做啥的？学这玩意儿干啥？" class="headerlink" title="啥？做啥的？学这玩意儿干啥？"></a>啥？做啥的？学这玩意儿干啥？</h3><p>numpy, pytorch, tensorflow中有个函数叫做einsum, 它的来源是Einstein notation, 中文译作爱因斯坦求和约定，这约定是由阿尔伯特·爱因斯坦于1916年提出的。</p><p>采用爱因斯坦求和约定，可以使数学表达式显得简洁明快。而将这种简洁记法运用到矩阵运算代码中会带来什么好处呢？</p><p>我们来看numpy官方关于einsum的文档是怎么说的，让我们来 <del>抄</del> 引用一下</p><blockquote><p>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In <em>implicit</em> mode <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html#numpy.einsum"><code>einsum</code></a> computes these values.</p></blockquote><p>许多常见的多维度操作都可以被einsum这一个函数表示，那么有哪些常见操作呢？<del>抄之</del> 引用之</p><blockquote><p>A non-exhaustive list of these operations, which can be computed by <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html#numpy.einsum"><code>einsum</code></a>, is shown below along with examples:</p><ul><li>Trace of an array, <a href="https://numpy.org/doc/stable/reference/generated/numpy.trace.html#numpy.trace"><code>numpy.trace</code></a>.</li><li>Return a diagonal, <a href="https://numpy.org/doc/stable/reference/generated/numpy.diag.html#numpy.diag"><code>numpy.diag</code></a>.</li><li>Array axis summations, <a href="https://numpy.org/doc/stable/reference/generated/numpy.sum.html#numpy.sum"><code>numpy.sum</code></a>.</li><li>Transpositions and permutations, <a href="https://numpy.org/doc/stable/reference/generated/numpy.transpose.html#numpy.transpose"><code>numpy.transpose</code></a>.</li><li>Matrix multiplication and dot product, <a href="https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul"><code>numpy.matmul</code></a> <a href="https://numpy.org/doc/stable/reference/generated/numpy.dot.html#numpy.dot"><code>numpy.dot</code></a>.</li><li>Vector inner and outer products, <a href="https://numpy.org/doc/stable/reference/generated/numpy.inner.html#numpy.inner"><code>numpy.inner</code></a> <a href="https://numpy.org/doc/stable/reference/generated/numpy.outer.html#numpy.outer"><code>numpy.outer</code></a>.</li><li>Broadcasting, element-wise and scalar multiplication, <a href="https://numpy.org/doc/stable/reference/generated/numpy.multiply.html#numpy.multiply"><code>numpy.multiply</code></a>.</li><li>Tensor contractions, <a href="https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html#numpy.tensordot"><code>numpy.tensordot</code></a>.</li><li>Chained array operations, in efficient calculation order, <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum_path.html#numpy.einsum_path"><code>numpy.einsum_path</code></a>.</li></ul></blockquote><p>”奥这样啊，看起来还行“，看你若有所思的样子我就知道你在想什么。</p><p>你可能会说这不就是一种语法糖么？相当于原来我用代码抄公式要花5行代码，现在就一行了，但是so what? 只是个小trick罢了。</p><p>的确如果只是处理较低的维度矩阵的话，似乎是这样。</p><p>但当我们涉及到需要频繁处理复杂的高维度矩阵操作的时候，这个方法的简洁高效性就体现出来了。</p><p>让我们来一些复杂点的例子。</p><p>首先让我们来看看对一个7维矩阵中的部分维度进行转置的例子</p><p>假设我们有一个矩阵$A$，它的形状为$1\times3\times4\times2\times3\times64\times64$，现在希望互换部分维度，转化为$1\times3\times4\times64\times64\times2\times3$，我们来看看两种方法分别做起来是什么样子的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.random.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">legacy_result = a.transpose(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>)<span class="comment"># 通常方法</span></span><br><span class="line">einsum_result = np.einsum(<span class="string">&quot;bcijkwh-&gt;bciwhjk&quot;</span>, a)<span class="comment"># Einsum</span></span><br><span class="line"><span class="built_in">print</span>((legacy_result==einsum_result).<span class="built_in">all</span>()) <span class="comment"># 查看是否等价</span></span><br><span class="line"><span class="comment">#----输出True</span></span><br></pre></td></tr></table></figure><p>从上面这个例子中，我们可以看出利用einsum的任意标签特性，我们可以给各个维度赋予一个有含义的标签（比如b代表batch，c代表channel等等）。如此便比比直接使用index操作更加直观可读，不容易出错。</p><p>但这也不过如此，einsum的强大之处不只体现在这里。</p><p>我们再来看一个例子。</p><p>如何用写一个维度为$1\times3\times4\times2\times3\times64\times64$和$1\times3\times4\times(2\times3)^T\times64\times64$的倒数第4，3个维度的矩阵积并得到$1\times3\times4\times2\times2\times64\times64$的结果?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">b = np.random.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line"><span class="comment"># 传统做法, 先把要乘的转置到最后，完成运算后再转置回来</span></span><br><span class="line">a1=a.transpose(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># Shape(1, 3, 4, 64, 64, 2, 3)</span></span><br><span class="line">b1=b.transpose(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># Shape(1, 3, 4, 64, 64, 3, 2)</span></span><br><span class="line">legacy_result = np.matmul(a1,b1) <span class="comment"># Shape(1, 3, 4, 64, 64, 2, 2)</span></span><br><span class="line">legacy_result = legacy_result.transpose(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># Shape(1, 3, 4, 2, 2, 64, 64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 很麻烦对不对？那如果用einsum来做呢？</span></span><br><span class="line">einsum_result = np.einsum(<span class="string">&#x27;...ijhw,...kjhw-&gt;...ikhw&#x27;</span>, a,b) <span class="comment"># Shape(1, 3, 4, 2, 2, 64, 64)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((legacy_result==einsum_result).<span class="built_in">all</span>())<span class="comment"># 我们来验证一下结果是否一致</span></span><br><span class="line"><span class="comment"># --------输出--------</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>非常amazing是不是？显然einsum在这个例子上体现出了绝对的优越性。</p><h3 id="不升华一下似乎很难收场-´ο｀"><a href="#不升华一下似乎很难收场-´ο｀" class="headerlink" title="不升华一下似乎很难收场(´ο｀*)))~"></a>不升华一下似乎很难收场(´ο｀*)))~</h3><p>其实有时候同样的事情换个角度看就会有很大的不同。你可以说这只是一种新的记法，记法嘛，无外乎只是写起来麻烦些和简单些的区别，但是你往往会发现不同的记法往往不仅仅是节省墨水，更可以为你提供更简洁的思维封装单元，同时还能腾出更多的思维时间。</p><p>就像集成电路里的芯片，14纳米和5纳米的芯片虽然整体实现的功能完全一样，尺寸听起来似乎也不是差得很多，但它在相同资源空间内带来的不同堆集效应是无法忽视的。</p><p>回到我们探讨的问题上，你往往会发现，随着矩阵维度的增高，你的精力会逐渐被思考这个地方该如何转置，那个维度该怎么堆叠这些无关宏观目标的具体细节所分散。</p><p>(好吧，听起来丝毫没有说服力~)</p><p>在此我只是试图浅薄地理解由Numpy最早引入的einsum函数在具体工程问题上的一些好处，更深层次的东西我就没有能力再去探讨了。</p><p>不过说实在的，我目前也只是直觉上觉得学这个东西具有巨大的作用。实质上我也是刚开始学而已，暂时也说不出什么太实质性的感悟。只是我在读<a href="https://github.com/lucidrains/vit-pytorch/blob/main/vit_pytorch/vit_pytorch.py"><code>vit-pytorch</code></a> 代码的时候，发现它对Transformer的核心实现大量的采用了einsum以及受它启发的einops，感觉非常简洁明快，并且在你理解它的意思后，会发现这种符号记法远远比<code>np.inner(a,b)</code>又或是<code>transpose(2,1,3,2)</code>来得直观地多。</p><p>正是它给我带来的这种直观印象促使了我决定放下手头的工作，好好地把它学一下，我相信它会给我以后的工作和思考带来持续的好处，从这个角度看，我这么做是很值得的。百忙中走一步闲棋，后效如何，还待他日探讨。</p><p>（当然我才不会承认还有一部分原因是因为这个方法冠有爱因斯坦的鼎鼎大名，实为炫技装逼之利器也~）</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html">Numpy 文档</a></p><p>[2] Einstein notation, <a href="https://en.wikipedia.org/wiki/Einstein_notation">Wikipedia</a></p><p>[3] 爱因斯坦求和约定，<a href="https://baike.baidu.com/item/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E6%B1%82%E5%92%8C%E7%BA%A6%E5%AE%9A/2477100?fr=aladdin">百度词条</a></p><h2 id="Einops"><a href="#Einops" class="headerlink" title="Einops"></a>Einops</h2><h3 id="这又是啥？-⊙o⊙-学不动了，告辞。"><a href="#这又是啥？-⊙o⊙-学不动了，告辞。" class="headerlink" title="这又是啥？(⊙o⊙)学不动了，告辞。"></a>这又是啥？(⊙o⊙)学不动了，告辞。</h3><p>哎别走嘛，来来，我们来看个小视频。（骗你的，其实是个动图）</p><p><img src="http://arogozhnikov.github.io/images/einops/einops_video.gif" alt="官方文档盗过来的一张动图"></p><p>不得不说作者还是蛮会的，这个动图简洁明了，相信你看完之后一定会很直观地get到这个项目能实现什么效果：厉害吧？你要不要学？</p><p>接着放几个大佬的Tweets评价来背书：快来用呀，大佬们都说好哦~</p><p>还支持Numpy，Pytorch，TensorFlow，Jax等诸多框架，哇，满满的都是高级感呀，2.5K个Star一点也不奇怪。</p><p>不知道你有没有心动了，反正我是心动了，感觉学完就能和爱因斯坦以及硅谷大佬肩并肩，走上人生巅峰啊~  <code>^▽^</code></p><p>（醒醒，你只是为了读懂别人的代码）</p><p>那就一起来看看吧~。<br>（原来哄自己学习也这么辛苦的么）</p><p>额，突然不想写了，先酱紫吧，回头再更，拜~(害，还是没哄成)</p><h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><p>[1]<a href="https://github.com/arogozhnikov/einops#supported-frameworks">https://github.com/arogozhnikov/einops#supported-frameworks</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一起来学-Einsum，Einops&quot;&gt;&lt;a href=&quot;#一起来学-Einsum，Einops&quot; class=&quot;headerlink&quot; title=&quot;一起来学 Einsum，Einops&quot;&gt;&lt;/a&gt;一起来学 Einsum，Einops&lt;/h1&gt;&lt;h2 id=&quot;E</summary>
      
    
    
    
    <category term="AI" scheme="http://blog.yinzi.me/categories/AI/"/>
    
    
    <category term="AI" scheme="http://blog.yinzi.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>MacOS Acrobat Pro DC 屏蔽更新</title>
    <link href="http://blog.yinzi.me/post/acrobat-updater-remove/"/>
    <id>http://blog.yinzi.me/post/acrobat-updater-remove/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装与去付费"><a href="#安装与去付费" class="headerlink" title="安装与去付费"></a>安装与去付费</h1><p>磁力链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:AD362136562FC716C6CACACF926CEA55EF5E25B2&amp;dn=Adobe_Acrobat_DC_v20.006.20042__TNT_Torrentmac.net.dmg</span><br></pre></td></tr></table></figure><h1 id="屏蔽更新"><a href="#屏蔽更新" class="headerlink" title="屏蔽更新"></a>屏蔽更新</h1><p>Reference:<a href="https://www.reddit.com/r/AdobeZii/comments/fkzqol/solved_how_to_disable_adobe_acrobat_reader_dc/">https://www.reddit.com/r/AdobeZii/comments/fkzqol/solved_how_to_disable_adobe_acrobat_reader_dc/</a></p><blockquote><p>I found that this solution helps:</p><p>Right-click Adobe Acrobat.app, go to “Contents” -&gt; “Plugins” and delete Updater.acroplugin.</p></blockquote><p>运行以下命令即可：</p><p><code>rm -rf /Applications/Adobe Acrobat DC/Adobe Acrobat.app/Contents/Plugins/Updater.acroplugin</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装与去付费&quot;&gt;&lt;a href=&quot;#安装与去付费&quot; class=&quot;headerlink&quot; title=&quot;安装与去付费&quot;&gt;&lt;/a&gt;安装与去付费&lt;/h1&gt;&lt;p&gt;磁力链：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="实用技巧" scheme="http://blog.yinzi.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="Adobe" scheme="http://blog.yinzi.me/tags/Adobe/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 部署VMESS+TCP+TLS</title>
    <link href="http://blog.yinzi.me/post/depoly_vmess_tcp_tls_on_centos7/"/>
    <id>http://blog.yinzi.me/post/depoly_vmess_tcp_tls_on_centos7/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>由于忍不住剁手新入一台韩国Kdatacenter的VPS，从南京联通出去的链路还是不错的，如图所示。<br><img src="https://i.loli.net/2020/06/17/tvlpqiFUckWEjsQ.png" alt="image.png"></p><p>于是乎，需要给它重新配置一些东西。默认给的操作系统是CentOS6，我发工单改成了CentOS7。它家工单系统蛮有意思的，我半夜三点钟发居然十分钟后就回复了，看来是有其他时区的客服。</p><p>最近发现官方社区出了TCP+TLS的指南，不再是以前的Websocket+TLS，而是参照Trojan的TCP+TLS的思路，用Haproxy作为443前端根据流量特征进行中转，具体来说就是，如果接入流量真的是http流量的话，那么就送到nginx后端，如果是其他流量的话，那么就把它送到v2ray的VMESS端口里。以前的方式是固定web path里的统统用websocket反向代理到VMESS端口。现在这种TCP+TLS的方式根据测试延迟会比以前低一些。</p><p>我个人第一想法是感觉额外添加一个Haproxy出来不够美观，~~最近时间紧，我就不要去探索了，2333~~~~   之前没看仔细，已经有人搭了只靠nginx转发的了。</p><h5 id="以下所有操作默认都在root用户中执行"><a href="#以下所有操作默认都在root用户中执行" class="headerlink" title="以下所有操作默认都在root用户中执行"></a>以下所有操作默认都在root用户中执行</h5><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h3 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h3><p>我的域名是在Cloudflare上解析的，登录Cloudflare，之后创建A记录到我服务器的IP即可。</p><h3 id="2-安装nginx"><a href="#2-安装nginx" class="headerlink" title="2.安装nginx"></a>2.安装nginx</h3><p>最省事的方法是直接用APT或者YUM装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y vim</span><br><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>修改配置<code>vim /etc/nginx/nginx.conf</code>，找到server_name这一项，将localhost改为自己的域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;#记得改成你自己的域名</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><h3 id="3-申请证书"><a href="#3-申请证书" class="headerlink" title="3.申请证书"></a>3.申请证书</h3><p>要用正常的TLS得有签名的证书才行，这里我们采用certbot来实现 lets encrypt证书的申请和自动续期</p><h4 id="3-1-下载certbot"><a href="#3-1-下载certbot" class="headerlink" title="3.1 下载certbot"></a>3.1 下载certbot</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure><h4 id="3-2-选择Certbot的运行方式"><a href="#3-2-选择Certbot的运行方式" class="headerlink" title="3.2 选择Certbot的运行方式"></a>3.2 选择Certbot的运行方式</h4><p>由于我们不需要nginx直接监听443，因此这里建议仅生成证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --nginx</span><br></pre></td></tr></table></figure><p>成功之后证书存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate /etc/letsencrypt/live/your_domain/fullchain.pem; # managed by Certbot</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/your_domain/privkey.pem; # managed by Certbot</span><br></pre></td></tr></table></figure><h4 id="3-3-设定自动续期"><a href="#3-3-设定自动续期" class="headerlink" title="3.3 设定自动续期"></a>3.3 设定自动续期</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;0 0,12 * * * root python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew -q&quot; | sudo tee -a /etc/crontab &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="4-配置Haproxy"><a href="#4-配置Haproxy" class="headerlink" title="4.配置Haproxy"></a>4.配置Haproxy</h3><h4 id="4-1-编译openssl-1-1-1"><a href="#4-1-编译openssl-1-1-1" class="headerlink" title="4.1 编译openssl 1.1.1"></a>4.1 编译openssl 1.1.1</h4><h5 id="我们需要openssl1-1-1要支持TLS-1-3"><a href="#我们需要openssl1-1-1要支持TLS-1-3" class="headerlink" title="我们需要openssl1.1.1要支持TLS 1.3"></a>我们需要openssl1.1.1要支持TLS 1.3</h5><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &#x27;Development Tools&#x27;</span><br></pre></td></tr></table></figure><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz</span><br><span class="line">tar -xzf openssl-1.1.1g.tar.gz</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd openssl-OpenSSL_1_1_1g/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常可以直接使用config (from Ubuntu 13.04, x64, 本文在CentOS7.3测试通过):</span></span><br><span class="line">./config --prefix=/opt/openssl-1.1.1 shared</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="4-2-编译haproxy"><a href="#4-2-编译haproxy" class="headerlink" title="4.2 编译haproxy"></a>4.2 编译haproxy</h4><p>源码下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y make gcc perl pcre-devel zlib-devel pcre2 pcre2-devel</span><br><span class="line">wget http://www.haproxy.org/download/1.9/src/haproxy-1.9.15.tar.gz</span><br><span class="line">tar -zxvf haproxy-1.9.15.tar.gz</span><br><span class="line">cd haproxy-1.9.15/</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make TARGET=linux2628 CPU=native USE_PCRE2=1 USE_PCRE2_JIT=1 USE_OPENSSL=1 SSL_LIB=/opt/openssl-1.1.1/lib SSL_INC=/opt/openssl-1.1.1/include USE_ZLIB=1</span><br><span class="line">make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check your sbin path at /usr/local/sbin</span></span><br><span class="line">cp haproxy /usr/local/sbin/haproxy</span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/haproxy/</span><br><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure><p>代码内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log local0</span><br><span class="line">    log /dev/log local1 notice</span><br><span class="line">    #chroot /var/lib/haproxy</span><br><span class="line">    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners</span><br><span class="line">    stats timeout 30s</span><br><span class="line">    #user haproxy</span><br><span class="line">    #group haproxy</span><br><span class="line">    daemon</span><br><span class="line">    ca-base /etc/ssl/certs</span><br><span class="line">    crt-base /etc/ssl/private</span><br><span class="line"></span><br><span class="line">    # 仅使用支持 FS 和 AEAD 的加密套件</span><br><span class="line">    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384</span><br><span class="line">    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line">    # 禁用 TLS 1.2 之前的 TLS</span><br><span class="line">    ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11</span><br><span class="line"></span><br><span class="line">    tune.ssl.default-dh-param 2048</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    # 我们需要使用 tcp 模式</span><br><span class="line">    mode tcp</span><br><span class="line">    option dontlognull</span><br><span class="line">    timeout connect 5s</span><br><span class="line">    # 空闲连接等待时间，这里使用与 V2Ray 默认 connIdle 一致的 300s</span><br><span class="line">    timeout client  300s</span><br><span class="line">    timeout server  300s</span><br><span class="line">frontend tls-in</span><br><span class="line">    # 监听 443 tls，tfo 根据自身情况决定是否开启，证书放置于 /etc/ssl/private/example.com.pem</span><br><span class="line">    bind *:443 tfo ssl crt /etc/ssl/private/example.com.pem</span><br><span class="line">    tcp-request inspect-delay 5s</span><br><span class="line">    tcp-request content accept if HTTP</span><br><span class="line">    # 将 HTTP 流量发给 web 后端</span><br><span class="line">    use_backend web if HTTP</span><br><span class="line">    # 将其他流量发给 vmess 后端</span><br><span class="line">    default_backend vmess</span><br><span class="line"></span><br><span class="line">backend web</span><br><span class="line">    server server1 127.0.0.1:8080</span><br><span class="line">  </span><br><span class="line">backend vmess</span><br><span class="line">    server server1 127.0.0.1:40001</span><br></pre></td></tr></table></figure><p>HaProxy 的证书和密钥放于同一个文件，与 Caddy 和 Nginx 不同，可以使用命令 <code>cat example.com.crt example.com.key &gt; example.com.pem</code> 合成证书</p><p>修改haproxy系统服务启动脚本：</p><p><code>vim /etc/systemd/system/haproxy.service </code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保在[Service]这一栏有这样的一项</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=LD_LIBRARY_PATH=/opt/openssl-1.1.1/lib/</span><br></pre></td></tr></table></figure><p>测试，首先测试配置是否正确，如果发现错误就根据错误改正</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -db -f /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/haproxy start</span><br></pre></td></tr></table></figure><p>如果没有任何提示，说明haproxy配置无误，Ctrl+C退出测试。</p><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start haproxy</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable haproxy</span><br></pre></td></tr></table></figure><p>此时输入<code>netstat -npl |grep 443</code>可以看到haproxy已经开始监听443端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      23824/haproxy</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     290695   23824/haproxy        /run/haproxy/admin.sock.23823.tmp</span><br></pre></td></tr></table></figure><h4 id="Haproxy常见错误排查"><a href="#Haproxy常见错误排查" class="headerlink" title="Haproxy常见错误排查"></a>Haproxy常见错误排查</h4><p>如果提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ALERT] 168/131339 (22782) : Starting frontend GLOBAL: cannot bind UNIX socket [/run/haproxy/admin.sock]</span><br></pre></td></tr></table></figure><p>首先检查443端口是否被占用，先把apache，nginx, caddy关掉，之后的章节会提到，我们会将它的监听端口改为其他端口，用haproxy作实际443监听端口。</p><p>使用<code>netstat -npl |grep 443</code>检查是否有进程占用443端口。</p><p>如果确认没有，但仍然报错，则需要手动创建&#x2F;run&#x2F;haproxy&#x2F;这个目录：</p><blockquote><p>Haproxy needs to write to <code>/run/haproxy/admin.sock</code> but it wont create the directory for you. Create the directory <code>/run/haproxy/</code> first or set <code>stats socket</code> to a different path.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /run/haproxy/</span><br></pre></td></tr></table></figure><h5 id="请注意"><a href="#请注意" class="headerlink" title="请注意:"></a>请注意:</h5><p><em><strong>1.务必先编译openssl 1.1.1再编译haproxy，可以通过<code>haproxy -vv |grep OpenSSL</code>查看当前编译时候openssl的版本，如果版本号不对，请指定正确版本的openssl路径后重新编译</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">haproxy -vv |grep OpenSSL</span><br><span class="line">----</span><br><span class="line">Built with OpenSSL version : OpenSSL 1.1.1g  21 Apr 2020</span><br><span class="line">Running on OpenSSL version : OpenSSL 1.1.1g  21 Apr 2020</span><br><span class="line">OpenSSL library supports TLS extensions : yes</span><br><span class="line">OpenSSL library supports SNI : yes</span><br><span class="line">OpenSSL library supports : TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3</span><br></pre></td></tr></table></figure><h3 id="配置v2ray服务端"><a href="#配置v2ray服务端" class="headerlink" title="配置v2ray服务端"></a>配置v2ray服务端</h3><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p>配置<br><code>vim /etc/v2ray/config.json</code></p><p>内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">40001</span><span class="punctuation">,</span># 可以随便写个端口，只要注意一致就行</span><br><span class="line">            <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2435e5c-9ad9-4367-836a-8341117d0a5f&quot;</span>(请自己生成一个)</span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start v2ray</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable v2ray</span><br></pre></td></tr></table></figure><h2 id="修改nginx服务端配置"><a href="#修改nginx服务端配置" class="headerlink" title="修改nginx服务端配置"></a>修改nginx服务端配置</h2><p><code>vim /etc/nginx/nginx.conf</code></p><p> 在 http{} 里面添加，这样我们只用nginx监听普通8080端口即可，因为haproxy那边本地转发前已经解包成了明文了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name example.com;#记得改成你自己的域名</span><br><span class="line">  root /var/www/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>到目前为止，所有的服务就已经搭建完毕了，在浏览器里输入 https:&#x2F;&#x2F; + 你的域名，  如果能够正常访问，说明haproxy和nginx的链路已经通了，基本上就代表可以用了。VMESS的路一般不会出什么问题，这时候就可以用客户端试一下了。</p><p>客户端的配置以及一些延迟测试就不多介绍了，参考<a href="https://guide.v2fly.org/advanced/tcp_tls_web.html">官方社区</a>吧。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>油管1080P随便拽，4k流畅秒开，可以看奈飞</p><p>油管4k</p><p><img src="https://i.loli.net/2020/06/17/GHRKqbBelJAC34k.png" alt="image.png"><br>Netflix<br><img src="https://i.loli.net/2020/06/17/IHzUFPDVqvuhTWQ.png" alt="image.png"></p><h1 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h1><p>1.整个一套配置下来还是很繁琐的。我打算之后写一套docker-compose，以方便复用。</p><p>2.这个机器有100G硬盘呢，反正暂时又不建站，不如下一步在上面建个图床玩玩</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://www.cnblogs.com/stulzq/p/9291223.html">CentOS 7 源码编译安装 Nginx</a></p><p>2.<a href="https://guide.v2fly.org/advanced/tcp_tls_web.html#%E8%83%8C%E6%99%AF">TCP + TLS + Web</a></p><p>3.<a href="https://gist.github.com/meanevo/742b61031fdf9ce01e50d4b196a3f31e">HAproxy指南之haproxy编译安装</a></p><p>4.<a href="https://wiki.openssl.org/index.php/Compilation_and_Installation">wiki_openssl</a></p><p>5.<a href="https://dnsprivacy.org/wiki/display/DP/Building+HAProxy+so+that+it+can+use+TLSv1.3">Building HAProxy so that it can use TLSv1.3</a></p><p>6.<a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx.html">Nginx on CentOS&#x2F;RHEL 7</a></p><p>7.<a href="https://stackoverflow.com/questions/30101075/haproxy-doesnt-start-can-not-bind-unix-socket-run-haproxy-admin-sock">HAProxy doesn’t start, can not bind UNIX socket</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;由于忍不住剁手新入一台韩国Kdatacenter的VPS，从南京联通出去的链路还是不错的，如图所示。&lt;br&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://blog.yinzi.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Network" scheme="http://blog.yinzi.me/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Kdatacenter迁移记录</title>
    <link href="http://blog.yinzi.me/post/record_of_my_migration/"/>
    <id>http://blog.yinzi.me/post/record_of_my_migration/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近套路云翻车，Linode总是不稳定，所以我打算把个人的另一个站点以及某类工具性服务迁移到一个更加稳定的地方去。思来想去，还是得在亚洲机房找。</p><p>之前看网上有不少博客推荐<a href="https://www.kdatacenter.com/">Kdatacenter</a>，说是最稳定最快速的韩国VPS，速度就像是在国内访问一样，所以就想去试试。</p><p>并且听说这家提供商可以给新用户20%的优惠，不过需要用户发推广：</p><blockquote><p>You can get some promotion codes according to quantity of links as below:</p><p>*10% promotion code: 1ealink x Blog&#x2F;BBS&#x2F;Forum etc.</p><p>*Additional 10% promotion code: 2ea links x SNS</p><p>You can get 20% promotion code with 3 links:</p><ul><li>Your post in forum or BBS can be considered as an article in SNS.</li><li>A promotion coupon is avaliable only one time. These coupons are used for recurring charge.</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于最近套路云翻车，Linode总是不稳定，所以我打算把个人的另一个站点以及某类工具性服务迁移到一个更加稳定的地方去。思来想去，还是得在亚洲</summary>
      
    
    
    
    <category term="计算机相关技术" scheme="http://blog.yinzi.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mac OS" scheme="http://blog.yinzi.me/tags/Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>这是个草稿</title>
    <link href="http://blog.yinzi.me/post/nothing-but-a-draft/"/>
    <id>http://blog.yinzi.me/post/nothing-but-a-draft/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<p>没什么积累和输入自然是写不出什么好东西</p><p>反正就是个草稿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没什么积累和输入自然是写不出什么好东西&lt;/p&gt;
&lt;p&gt;反正就是个草稿&lt;/p&gt;
</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/tags/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>我非我</title>
    <link href="http://blog.yinzi.me/post/I-am-not-me/"/>
    <id>http://blog.yinzi.me/post/I-am-not-me/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2026-01-11T15:36:25.298Z</updated>
    
    <content type="html"><![CDATA[<p>我非我，即小我，及大我，何曾无我。</p><p>我若成我，我亦非我。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我非我，即小我，及大我，何曾无我。&lt;/p&gt;
&lt;p&gt;我若成我，我亦非我。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/tags/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>淘宝买的mini IPC摄像头分析</title>
    <link href="http://blog.yinzi.me/post/analysis-of-a-mini-camera/"/>
    <id>http://blog.yinzi.me/post/analysis-of-a-mini-camera/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<p>一个超级mini的摄像头，带夜视、H.264编码、低功耗声称可以续航三天</p><p><img src="https://i.loli.net/2021/03/03/lpSXdr6InRFQw4o.jpg" alt="image-20190923001151881.jpg"><br><img src="https://i.loli.net/2021/03/03/7lxXHrmAyGPYD3I.jpg" alt="image-20190923001203049.jpg"></p><p>拆开看是这样</p><p><img src="https://i.loli.net/2021/03/03/nvH3Tbgh765lqyo.jpg" alt="image-20190923001216989.jpg"><br><img src="https://i.loli.net/2021/03/03/hKtpbwgyL6M7GAB.jpg" alt="image-20190923001224351.jpg"></p><p>用的这个芯片很有意思</p><p>北京君正芯片</p><p><img src="http://img.mp.itc.cn/upload/20170424/9b77e860de47463eae9494bf8adc0786_th.jpeg" alt="img"></p><p>大概抓包分析了一下，貌似是直接把TLS加密的内容用Raw UDP传送。</p><p>首先我发现它提供APP上有一个推送新证书的功能，通过抓包成功地把证书和私钥给拿了下来。</p><p><img src="https://i.loli.net/2021/03/03/YB1W8UZTE2gKt4I.jpg" alt="image-20190923001727840.jpg"></p><p>然后发现它UDP端口每次都会变，而且APP支持局域网搜索，所以我猜想肯定是有UDP广播，所以就抓广播包，果然抓到了关键信息。这个XML文件的信息量很大，表明了它是用onvif协议（表示在看到这个关键词的时候都不知道这啥啊，搜一下才知道原来是一个定好的标准协议，我之前还以为是作者自定义的协议。毕竟不了解IP摄像头行业，2333）</p><p><img src="https://i.loli.net/2021/03/03/mt4RfykWX2Y6sHL.jpg" alt="image-20190923002052357.jpg"></p><p>另外，我还发现了这个板子的串口，哈哈哈，这意味着可以直接拿到shell了，回头焊个排针引出来然后把ssh 打开，真是捡到宝了，开心～</p><p><img src="https://i.loli.net/2021/03/03/5ajSpGk47undhfv.jpg" alt="image-20190923002550162.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个摄像头的设计很简单又紧凑，值得学习。这个小体积和续航非常符合我的要求，下一步的目标就是对它进行二次开发了～ 加个人脸识别啥的,真是太美好了～～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个超级mini的摄像头，带夜视、H.264编码、低功耗声称可以续航三天&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/03/lpSXdr6InRFQw4o.jpg&quot; alt=&quot;image-20190923001151881.jpg</summary>
      
    
    
    
    <category term="Diy" scheme="http://blog.yinzi.me/categories/Diy/"/>
    
    
    <category term="Others" scheme="http://blog.yinzi.me/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>随笔4-191027</title>
    <link href="http://blog.yinzi.me/post/totally-gibberish/"/>
    <id>http://blog.yinzi.me/post/totally-gibberish/</id>
    <published>2019-10-26T16:00:00.000Z</published>
    <updated>2026-01-11T15:35:01.631Z</updated>
    
    <content type="html"><![CDATA[<p>我年少时糊涂，痴痴傻傻。到如今，却越活越明白。一路上身边的人很多，留下来的却很少。有的朋友三言两句就觉得淡薄了，有的朋友十年阔别，再谈却还总觉得熟络。其实我哪经营得过来那么多感情，人生难得一知己。</p><p>我的朋友很少、但是我现在过得还不错，如果你乐意听到，那你就是我朋友，如果你十年后还有兴趣知道，那你就是我知己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我年少时糊涂，痴痴傻傻。到如今，却越活越明白。一路上身边的人很多，留下来的却很少。有的朋友三言两句就觉得淡薄了，有的朋友十年阔别，再谈却还总觉得熟络。其实我哪经营得过来那么多感情，人生难得一知己。&lt;/p&gt;
&lt;p&gt;我的朋友很少、但是我现在过得还不错，如果你乐意听到，那你就是我</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/tags/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>秋天好像来了</title>
    <link href="http://blog.yinzi.me/post/no-autumn-in-beijing/"/>
    <id>http://blog.yinzi.me/post/no-autumn-in-beijing/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2026-01-11T15:34:52.567Z</updated>
    
    <content type="html"><![CDATA[<p>这枫叶的颜色真可爱，红里透着点粉，像是夕霞融入了水里，又像是红焰突然害了羞，微敛了光芒。这么美妙的渐变色，我媳妇肯定调不出来，但我还是很爱她。</p><p>秋天好像来了，来得静悄悄的，也不打招呼。我从小就觉得这些季节一点仪式感也没有，来的时候不给个提示，让我们有机会可以敲个锣打个鼓，然后再回家人人换上新衣服。走的时候也莫名其妙，冷不丁就走了，也不让人好好送送，道一句路上珍重。</p><p>珍重啥呀，来来去去的，我每年都会来，但不知道哪一年会再也看不见你。倒是我应该对你加倍嘱托，好好记住你的样子再走，明年回来再来找你。</p><p>可是我总担心你太孤独了，我有四个朋友，但是你只有自己。你不在了我还有的陪伴，但你走的却孤零零，何况也不知道会去到哪里，又是怎么找到来时的路。</p><p>在漫长的岁月面前，我一直都在，我心疼你却只有一瞬。你的一瞬灿烂无比，像是漫无边际夜空中的花火，又像是每一颗闪烁的流星，像是雨露滴入湖面泛起的涟漪，像每一样美妙珍贵却又短暂的事物，我们都很珍惜你，但你的一生实在太短暂，我不想太自私。</p><p>好了好了，我哪有你说得这么渺小可怜，我有家人相伴，有媳妇陪我，有自己热爱喜欢的事业。你说我装点了你，但你又何尝不是装点了我们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这枫叶的颜色真可爱，红里透着点粉，像是夕霞融入了水里，又像是红焰突然害了羞，微敛了光芒。这么美妙的渐变色，我媳妇肯定调不出来，但我还是很爱她。&lt;/p&gt;
&lt;p&gt;秋天好像来了，来得静悄悄的，也不打招呼。我从小就觉得这些季节一点仪式感也没有，来的时候不给个提示，让我们有机会可以敲</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="ConfusingMind" scheme="http://blog.yinzi.me/tags/ConfusingMind/"/>
    
  </entry>
  
  <entry>
    <title>懒得起标题了</title>
    <link href="http://blog.yinzi.me/post/too-lazy-to-write-a-title/"/>
    <id>http://blog.yinzi.me/post/too-lazy-to-write-a-title/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.968Z</updated>
    
    <content type="html"><![CDATA[<p>懒得起标题了</p><p>心里总是有一堆想法，落在纸上又什么都没了。可能是我太纠结于格式、文法，应该先忽略这些，只打草稿的。想到的时候感觉灵感很好，几乎能够一挥而就了，等到坐下来的时候，当时的热情、感动就只剩下碎片了，看不出什么端倪。先把碎片整理下来吧，以后记得随手保存。</p><p>泛着彩色的灵感泡泡，你看它光彩夺目，举世惊艳，但是你一伸手，它就破了，只能在指尖依稀感觉到一丝凉意。</p><p>美的事物有很多，阳光、叶子、花朵、你的目光</p><p>每一秒的时间都很昂贵，但每个人都好像无所谓，没关系，这个我付得起，没关系那个我也付得起。直到所剩无几，才希望能够多一秒，再多一秒。</p><p>得好好把握和珍惜，这一秒，下一秒。</p><p>珍贵是指一个事物这一刻还近在眼前的，下一刻可能再也遇不到了。这么说来，好多东西都是珍贵甚至奢侈的。每一个第一次，每一次不同的欣喜，每一个遇到的不同的路人，甚至是每一个不同的痛苦。</p><p>你看那摇椅里的老人，他们也曾是孩童。从襁褓到落地，从蹒跚到奔跑，从稚嫩到成熟，从一个人到遇到对的人。没人知道皱纹是怎样慢慢爬上他们的脸，时光又怎样慢慢磨掉他们平淡的回忆。我只想擦掉眼眶的泪，珍惜与你依偎在一起的每时每刻。纵然我们都挡不住时光。青春会老，容颜会老，我也会老；但我对你的爱不会老，这个承诺也不会老。</p><p>无力与时光抗争，当时光从你手中夺取，只能祈望有机会可以谈判。时光啊，把我的初心留下，把我爱的人留下，其他的你全都带走。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;懒得起标题了&lt;/p&gt;
&lt;p&gt;心里总是有一堆想法，落在纸上又什么都没了。可能是我太纠结于格式、文法，应该先忽略这些，只打草稿的。想到的时候感觉灵感很好，几乎能够一挥而就了，等到坐下来的时候，当时的热情、感动就只剩下碎片了，看不出什么端倪。先把碎片整理下来吧，以后记得随手保存。</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/tags/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>群体学习</title>
    <link href="http://blog.yinzi.me/post/why-people-hate-change/"/>
    <id>http://blog.yinzi.me/post/why-people-hate-change/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="群体学习论"><a href="#群体学习论" class="headerlink" title="群体学习论"></a>群体学习论</h2><h3 id="公理1：群体知识由个体学习结果提炼产生"><a href="#公理1：群体知识由个体学习结果提炼产生" class="headerlink" title="公理1：群体知识由个体学习结果提炼产生"></a>公理1：群体知识由个体学习结果提炼产生</h3><h3 id="公理2：个体更容易获得有更多个体经验的群体知识"><a href="#公理2：个体更容易获得有更多个体经验的群体知识" class="headerlink" title="公理2：个体更容易获得有更多个体经验的群体知识"></a>公理2：个体更容易获得有更多个体经验的群体知识</h3><h3 id="公理3-群体的知识空间是有限可数的"><a href="#公理3-群体的知识空间是有限可数的" class="headerlink" title="公理3:   群体的知识空间是有限可数的"></a>公理3:   群体的知识空间是有限可数的</h3><h3 id="群体学习方法："><a href="#群体学习方法：" class="headerlink" title="群体学习方法："></a>群体学习方法：</h3><p>这个问题很有意思，让我们来捋一捋。 </p><p>现象：对一个问题，看似比主流方案更优的解决方案却不一定有更大的用户群体。</p><p>群体反馈：“没有需求”，“你的方案不方便，学习成本过高”，“不够通用”，“我觉得现有方案就蛮好”，“哪那么多事，能用就好了”。</p><p>分析：</p><p>我们可以从这个角度来看，假设群体学习是这么一个过程：每个单独个体都基于自身的样本空间学习探索，虽然有些人的样本空间里探索不到方案，但总有些人会有机会探索到新的解决方案极值点（很难说是最值点），然后群体最终会从所有个体探索方案极值点中选取最小的作为群体用户解决方案。如果群体学习真的一直是这个过程的话，那么群体将总能不断找到解决方案的新的局部最优化点，对一个问题大家往往都会选择当前更佳的那种解决方案。但事实上会存在两个局限，</p><ul><li><p>首先是评价标准有很大的主观问题，即我不承认你那里极值点比我低。什么是更好？什么是最好？每个人的标准不一样，每个人的需求也不一样。你这个方案对你的需求是最好，可能对我的也就一般。</p></li><li><p>第二个局限性是由于学习成本和用户惯性的存在，很容易造成群体方案的心甘情愿过拟合，虽然我承认你极值点更低，但我就在这里不出来了，我挪过去好累啊，就在这里就蛮好。</p></li></ul><p>这两个局限性导致了群体性分布式学习很难学习到一个共同的最优解，只能存在一个主流的极值解。这就导致了解决同一个问题可以有不同的方法，但很难说谁是最好的。所以用户在对同一种问题的不同解决方案选择上我认为大体上可以分为三类群体，<strong>A群体，B群体和C群体。</strong></p><ul><li><p><strong>A群体</strong>用户数量最庞大，他们一般承认自己不是最优的解决方案，但根据局限1和局限2，拒绝迁移。</p></li><li><p><strong>B群体</strong>和<strong>C群体</strong>的数量可能相当也可能不相当，但是它们互相不承认对方更优，但是都公认自身比<strong>A群体</strong>更优。</p></li></ul><p>  随着时间发展，B群体或C群体完全可能成为新的A群体，但是保不准随着技术的不断前进，又会出现新的B群体和C群体，这样周而复始的也是非常的有意思。</p><h3 id="用户需求、用户惯性、学习成本"><a href="#用户需求、用户惯性、学习成本" class="headerlink" title="用户需求、用户惯性、学习成本"></a>用户需求、用户惯性、学习成本</h3><p>用户需求是需要培养的，没培养的时候用户更趋向于改变自己的需求去适应自身现有知识和技术，之后慢慢就形成了用户惯性。</p><p>个体用户对同一问题的求解过程可以看成如下过程：</p><ul><li>A事件：个体从现有知识样本空间探索查找解决方案，如果存在则查找结束。</li><li>B事件：个体从现有知识样本空间找不到方案，查看群体知识样本空间中是否有学习成本较低的方案，如果有，学习之，如果没有，则转C事件</li><li>C事件：看看这个需求是否非常重要，如果不是很重要，就直接放弃，否则转D事件</li><li>D事件：探索群体知识样本空间中学习成本高的方案是否满足要求，是则该项知识</li></ul><p>学习成本、用户惯性两者相辅相成：</p><p>1.学习成本促成了用户惯性，不存在学习成本也就很难有用户惯性。</p><p>不同用户由于背景知识的不同而对于同一种事物的学习成本不同，但用户往往会先从自身的低学习成本样本空间中探索方案来解决需求，一旦探索到某种方案能解决自身需求，则停止学习、存档，形成针对该问题的一个固定解决方案，也就是个体用户惯性。多个个体用户惯性会融合成群体用户惯性。</p><p>2.用户惯性又能反作用于学习成本，使新用户对该群体方案的学习成本更低，从而使该方案的群体增长。</p><p>一方面，受到每个人知识积累的不同，不是所有个体都能在自身的低学习成本空间中探索到解决方案，这时就需要学习，学会以后这个知识的学习成本对于该个体来说就降低了，也就是学会新知识相当于扩展了自身的低成本学习空间。</p><p>另一方面，即使个体的知识样本空间中理论上存在更优的解决方案，但是新的探索个体却需要付出更多的探索时间，这种自发探索也是一种学习，从其他任务知识中迁移学习到这个任务，但是这个过程的学习成本往往比直接使用成熟主流的群体解决方案来的高。除非成熟方案已经满足不了这部分个体的需求，否则这部分个体也不会选择继续探索新方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;群体学习论&quot;&gt;&lt;a href=&quot;#群体学习论&quot; class=&quot;headerlink&quot; title=&quot;群体学习论&quot;&gt;&lt;/a&gt;群体学习论&lt;/h2&gt;&lt;h3 id=&quot;公理1：群体知识由个体学习结果提炼产生&quot;&gt;&lt;a href=&quot;#公理1：群体知识由个体学习结果提炼产生&quot; c</summary>
      
    
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/categories/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
    
    <category term="脑子不好史" scheme="http://blog.yinzi.me/tags/%E8%84%91%E5%AD%90%E4%B8%8D%E5%A5%BD%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>LT3757电源控制模块学习笔记</title>
    <link href="http://blog.yinzi.me/post/electric/"/>
    <id>http://blog.yinzi.me/post/electric/</id>
    <published>2018-07-25T05:00:08.000Z</published>
    <updated>2026-01-11T14:08:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LT3757"><a href="#LT3757" class="headerlink" title="LT3757"></a>LT3757</h1><p>最近需要实现200V-350V的可调的输出电源，需要用到LT3757这款芯片，以前从来没有接触这方面的内容，仔细研读了一下LT3757的手册，为了便于以后查阅，在这里整理一下。</p><blockquote><p>PS:有些内容是按自己理解写的，如有纰误还望指教。</p></blockquote><p><img src="http://www.analog.com/lib/img/products/details/AltPartGeneric.png" alt="LT3757"></p><h2 id="LT3757简介"><a href="#LT3757简介" class="headerlink" title="LT3757简介"></a>LT3757简介</h2><blockquote><ul><li>LT 3757是一款DC-DC控制器，能够在宽输入范围内产生正或负输出电压，它可配置为反激式，SEPIC，BOOST或反相转换器，可以通过内部电源(INTVCC脚)或外接电源的方式来给N-MOSFET供电。</li><li>LT 3757A相比LT3757具有更好的负载瞬态性能</li></ul></blockquote><ul><li><p>它的工作频率可通过100kHz至1Mhz的Rt脚外接电阻调节，也可以通过SYNC脚与外部时钟同步的方式来调节，固定频率有利于在芯片很宽的电源和输出电压范围内稳定工作。</p></li><li><p>LT 3757的最小工作电源电压为2.9V，电流小于1uA。LT 3757具有软启动和频率折返功能，用于限制启动和输出短路期间的电感电流。</p></li></ul><span id="more"></span><h2 id="LT3757-各个引脚功能介绍"><a href="#LT3757-各个引脚功能介绍" class="headerlink" title="LT3757 各个引脚功能介绍"></a>LT3757 各个引脚功能介绍</h2><blockquote><ul><li>$V_{c}$: 误差放大器补偿引脚，利用外接RC网络来稳定电压回路。</li><li>$FBX$: 正电压和负电压反馈引脚。它通过输出电压部分的电阻分压来获得反馈电压，当反馈电压到达1.6V时，芯片便会调节开关频率使输出电压稳定下来不再继续升高。</li><li>另外，如果FBX接入GND，芯片也会在启动和故障的时候调制频率(说实话，这个功能没大读懂)。</li><li>$SS$: 软启动引脚，该引脚会调制$V_c$引脚的电压钳位，通过外部电容来控制软启动间隙。该引脚具有10uA(典型值)的上拉电流源，以及内部2.5V电压。在$\overline{SHDN}&#x2F;UVLO$引脚欠压，或者$INTV_{CC}$欠压过压以及芯片内部热锁定等异常条件下，SS将会被重置为GND电位。</li></ul></blockquote><p><strong>注:上已LT3757具有两种调节开关工作频率的方式，以下两个引脚便是具体的方式</strong></p><blockquote><ul><li>$RT$:开关频率调节引脚。通过在改脚外接电阻来调节工作频率，电阻的另一端直接接GND。此引脚不能悬空，即便要采用SYNC模式，该引脚也应该接入比SYNC脚接入频率低20%的频率对应的阻值。</li><li>$SYNC$:频率同步引脚。对应着外部时钟同步方式，该引脚用来接入外部信号源，以使开关频率与外部信号源频率同步，如果选用这个功能此时RT脚应该接入对应外部时钟频率低20%的频率的阻值。</li></ul></blockquote><hr><blockquote><ul><li>$SENSE$:控制回路的电流检测输入。此脚应连接到N-MOSFET源极中开关电流检测电阻的正极，电阻的负极应连接到IC的GND。<img src="https://s1.ax1x.com/2018/07/23/PJZjB9.png" alt="图2"></li><li>$GATE$:N沟道MOSFET栅极驱动器输出引脚。GATE脚是芯片的输出引脚，与N-MOSFET的栅极连接。输出波形是方波，电压在INTVCC和GND之间切换，相当于在以一定的频率切换MOS开关。当IC关闭、热锁定或者INTVCC欠压和超压时候自动接地。</li><li>$INTV_{CC}$:为内部负载和栅极驱动器提供的稳压电源，从VIN提供并调节至7.2V（典型值）。必须使用靠近引脚放置的最小4.7μF电容旁路INTVCC，如果VIN小于17.5V，INTVCC可以直接连接到VIN。如果电源电压不超过17.5V，INTVCC也可以连接到电压高于7.5V且低于VIN的电源。</li><li>$\overline{SHDN}&#x2F;UVLO$:关断和欠压检测引脚。到达1.22V（标称值）阈值便禁用设备并将VIN电流将至1μA以下，欠压条件下会重置软启动。</li><li>$V_{IN}$:VIN（引脚10）：输入电源引脚，必须旁路一个超过0.22μF的电容。</li></ul></blockquote><h2 id="LT3757-功能描述"><a href="#LT3757-功能描述" class="headerlink" title="LT3757 功能描述"></a>LT3757 功能描述</h2><p>由于是零基础,为了理解DC-DC升压的基本原理，从而了解LT3757的作用。我首先恶补了一下电力电子中BOOST、Flyback等常见电路的相关理论知识。但公式贴起来太枯燥，在这里不如让我引用一下电子工程世界论坛一位网友的科普贴，它讲得非常的生动易懂。</p><blockquote><p>当电感被连接到电源两端的时候，电流流过电感，这个过程会在电感周围产生感生磁场，当电流稳定之后，其磁场也趋于稳定。若我们将电源撤掉，磁场将会在线路中产生一个方向相反的电动势，其值可能大于原电源的电动势。明白了这两点，Boost电路的最基本原理也就不难分析了。<br><img src="http://5.eewimg.cn/data/attachment/forum/201709/15/152537sdihcsphhpvj3p9h.png.thumb.jpg" alt="升压电路"><br>在这样的一个电路中，如果我们闭合开关，电源将对电感充电，电能转化为电感上的磁场能量。而当我们打开开关，电感上的磁场将转化为电能，通过右侧的二极管向电容充电。而对于电容来说，其电压将取决于电源电压和电感的充电过程，在开关打开的时候，为其供电的除了电源，还有电感中的能量， 因此其电压将高于原电源电压。如果这个过程不断地往复下去，我们就能够在电容两端得到高于电源电压的输出电压。<br><img src="http://5.eewimg.cn/data/attachment/forum/201709/15/152612ynl4n2dvavpdm1vc.gif" alt="gif示意图"><br>很显然，在实际的电源中我们不可能用手去按开关，用在这个位置上的将会是开关管。它将以极快的速度开关，从而控制整个过程。这也是开关电源中“开关”一词的来历。</p></blockquote><p>而我们用到的LT3757实际上相当于一个开关控制器，通过控制电路的通断来实现能量从电感转移到电容，达到升压的目的。</p><h2 id="输出电压调节"><a href="#输出电压调节" class="headerlink" title="输出电压调节"></a>输出电压调节</h2><p>在手册的第12页 <em>Programing the Output Voltage</em> 节中给出了通过$R_1$和$R_2$电阻来调节输出电压的计算公式。<br>$V_{正输出电压}&#x3D;1.6V \cdot (1+\frac{R2}{R1})$<br>$V_{负输出电压}&#x3D;-0.8V \cdot (1+\frac{R2}{R1})$</p><p>FBX是反馈引脚，内部接1.6V和-0.8V的比较器。当反馈脚电压到达1.6V时芯片便会控制输出电压稳定，经过仿真发现改变FBX的电压不能很好地调节输出电压的值，会影响芯片对输出电压的控制。i</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;LT3757&quot;&gt;&lt;a href=&quot;#LT3757&quot; class=&quot;headerlink&quot; title=&quot;LT3757&quot;&gt;&lt;/a&gt;LT3757&lt;/h1&gt;&lt;p&gt;最近需要实现200V-350V的可调的输出电源，需要用到LT3757这款芯片，以前从来没有接触这方面的内容，仔细研读了一下LT3757的手册，为了便于以后查阅，在这里整理一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS:有些内容是按自己理解写的，如有纰误还望指教。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://www.analog.com/lib/img/products/details/AltPartGeneric.png&quot; alt=&quot;LT3757&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;LT3757简介&quot;&gt;&lt;a href=&quot;#LT3757简介&quot; class=&quot;headerlink&quot; title=&quot;LT3757简介&quot;&gt;&lt;/a&gt;LT3757简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;LT 3757是一款DC-DC控制器，能够在宽输入范围内产生正或负输出电压，它可配置为反激式，SEPIC，BOOST或反相转换器，可以通过内部电源(INTVCC脚)或外接电源的方式来给N-MOSFET供电。&lt;/li&gt;
&lt;li&gt;LT 3757A相比LT3757具有更好的负载瞬态性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它的工作频率可通过100kHz至1Mhz的Rt脚外接电阻调节，也可以通过SYNC脚与外部时钟同步的方式来调节，固定频率有利于在芯片很宽的电源和输出电压范围内稳定工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LT 3757的最小工作电源电压为2.9V，电流小于1uA。LT 3757具有软启动和频率折返功能，用于限制启动和输出短路期间的电感电流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="电子" scheme="http://blog.yinzi.me/categories/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="电子" scheme="http://blog.yinzi.me/tags/%E7%94%B5%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>IPV6折腾集</title>
    <link href="http://blog.yinzi.me/post/funwithIPV6/"/>
    <id>http://blog.yinzi.me/post/funwithIPV6/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文仅仅为探索过程的一个整理，针对：</p><ul><li>通过pppoe 用户名后面加@ipv6等后缀拨号获得单栈道IPV6地址的环境</li><li>不对IPV6地址进行计费和流量与访问限制的高校</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>本文相当于是博文集的序言和目录，相关内容正在持续更新中。- 由于我技术水平不高，所以文中的很多言论都只是我个人根据网上资料的理解，很多方法和技术也都是来自其他众多大牛们，我只是为了记录和整理折腾了一下方便我矿的童鞋们，顺便也能听取大家的建议和指教，更深入地了解相关的专业知识。不妥之处，还请各位包涵指点。</li><li>博主本人的水平有限，对于未解决的问题，希望能和大家一起讨论交流</li></ul><span id="more"></span><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li><p>虽然我的初衷确实是为了免费上网，但IPV6本身并不是用来免费上网的。希望感兴趣同学能深入了解和研究IPV6相关内容。</p></li><li><p>转载请征询本人意见。</p></li><li><p>涉嫌侵权知会本人删除。</p></li><li><p><strong>本集仅供技术交流，不得利用本文提及的相关技术进行任何不法行为、发表任何不正当言论以及谋取任何形式的商业利益!</strong></p></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h3><blockquote><ul><li><a href="https://aod321.github.io/post/knowaboutipv6/">了解IPV6</a></li><li><del>博主学校的IPV6网络结构浅析</del></li></ul></blockquote><h3 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h3><blockquote><ul><li>十年窗下无人问，<a href="https://aod321.github.io/post/v6resource/">V6资源介绍</a></li><li>一朝成名天下知，<a href="https://aod321.github.io/post/basicipv6/">IPV6初识</a></li><li>路漫漫其修远兮，IPV6常规化探索（转V4）</li><li>吾将上下而求索，充分利用IPV6带宽</li><li>雄关漫道真如铁，基于Openwrt的IPV6无线转发</li><li>而今迈步从头越，伪双栈-IPV6穿透</li></ul></blockquote><h3 id="探讨篇"><a href="#探讨篇" class="headerlink" title="探讨篇"></a>探讨篇</h3><blockquote><ul><li>国内的IPV6服务器</li><li>游戏低延时</li></ul></blockquote><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p><a href="http://lixingcong.github.io/">黎醒聪的博客</a><br><a href="http://ygcaicn.github.io/">蔡亚刚的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;本文仅仅为探索过程的一个整理，针对：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过pppoe 用户名后面加@ipv6等后缀拨号获得单栈道IPV6地址的环境&lt;/li&gt;
&lt;li&gt;不对IPV6地址进行计费和流量与访问限制的高校&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本文相当于是博文集的序言和目录，相关内容正在持续更新中。- 由于我技术水平不高，所以文中的很多言论都只是我个人根据网上资料的理解，很多方法和技术也都是来自其他众多大牛们，我只是为了记录和整理折腾了一下方便我矿的童鞋们，顺便也能听取大家的建议和指教，更深入地了解相关的专业知识。不妥之处，还请各位包涵指点。&lt;/li&gt;
&lt;li&gt;博主本人的水平有限，对于未解决的问题，希望能和大家一起讨论交流&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/categories/IPV6/"/>
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/tags/IPV6/"/>
    
  </entry>
  
  <entry>
    <title>V6初识</title>
    <link href="http://blog.yinzi.me/post/basicipv6/"/>
    <id>http://blog.yinzi.me/post/basicipv6/</id>
    <published>2018-01-31T11:00:32.000Z</published>
    <updated>2026-01-11T14:08:13.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h2><p>利用IPV6最直接的方式便是访问支持IPV6的站点，而不同高校获取IPV6地址方式不一样，很多都是上层交换机直接分配双栈的，所以只要简单配置获取一下V6公网地址就可以享受到相应的免流服务，有的学校则需要通过PPP验证来获取IPV6地址。</p><p>本章将演示如何在本地电脑上利用IPV6服务，首先讲演示如何通过PPP验证获取IPV6地址（其他高校需要具体问题具体分析，仅供参考），接着在获取到可用的IPV6公网地址以后对纯IPV6访问方式作简单的介绍与演示。</p><h2 id="主要要求"><a href="#主要要求" class="headerlink" title="主要要求"></a>主要要求</h2><blockquote><ul><li>装有Win7&#x2F;Win8&#x2F;Win10 系统的电脑一台</li><li>网线</li><li>对IPV6的基本应用有初步的了解。</li></ul></blockquote><span id="more"></span><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p>本章视频演示</p><iframe width="560" height="315" src="https://www.youtube.com/embed/P9CM4CA9kJg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>#以下是图文教程</p><hr><h2 id="通过PPPOE方式获取IPV6地址"><a href="#通过PPPOE方式获取IPV6地址" class="headerlink" title="通过PPPOE方式获取IPV6地址"></a>通过PPPOE方式获取IPV6地址</h2><p>步骤(请使用WIN7及以上版本系统)</p><p>1.由于本校IPV6在宿舍是通过电信的通道走的，</p><p>所以请<em>先用网线连接电信的网口</em>(每个人桌子上面或者下面应该都有)</p><p>2.新建拨号</p><p>网络-属性-添加新的连接或网络</p><p><img src="/post/basicipv6/1-1.png" alt="image1-1"> </p><p><img src="/post/basicipv6/1-2.png" alt="image1-2"></p><p>Win10用户也可以选择从在新的设置页面里选择建立新的连接如图所示</p><p><img src="/post/basicipv6/1.png" alt="image1"></p><p>3.在弹出的窗口选择连接到Internet 如图</p><p><img src="/post/basicipv6/2.png" alt="image2"></p><p>4.接着选择 宽带（PPPOE）</p><p><img src="/post/basicipv6/3.png" alt="image3"></p><p>5.重点来了，输入用户名和密码时</p><p>注意用户名的格式:<em>任意字符加上@ipv6后缀</em></p><p>，<em>密码可以随意填写</em>。如图所示</p><p><img src="/post/basicipv6/4.png" alt="image4"></p><p>6.选择跳过，然后关闭</p><p><img src="/post/basicipv6/5.png" alt="image5"><br>7.然后找到刚才新建的拨号，点击连接即可。</p><p><img src="/post/basicipv6/6.png" alt="image6"></p><p>8.设置一下Google的IPV6 DNS就可以访问支持IPV6的网页了</p><blockquote><ul><li>2001:4860:4860::8888</li><li>2001:4860:4860::8844</li></ul></blockquote><p>注：博主以前还见过有人说DNS设置成</p><blockquote><p>2001:778::37 </p></blockquote><p>就可以访问像QQ邮箱之类的V4地址网站。<br>这个DNS是个DNS64的通道，博主以前也用过，<em>目前测试这个通道已经失效了。</em></p><h2 id="访问纯IPV6资源"><a href="#访问纯IPV6资源" class="headerlink" title="访问纯IPV6资源"></a>访问纯IPV6资源</h2><p>纯IPV6可以直接访问站点不多，目前可以访问哪些资源请参考上一章<br><a href="https://aod321.github.io/post/v6resource/">V6资源介绍</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内容介绍&quot;&gt;&lt;a href=&quot;#内容介绍&quot; class=&quot;headerlink&quot; title=&quot;内容介绍&quot;&gt;&lt;/a&gt;内容介绍&lt;/h2&gt;&lt;p&gt;利用IPV6最直接的方式便是访问支持IPV6的站点，而不同高校获取IPV6地址方式不一样，很多都是上层交换机直接分配双栈的，所以只要简单配置获取一下V6公网地址就可以享受到相应的免流服务，有的学校则需要通过PPP验证来获取IPV6地址。&lt;/p&gt;
&lt;p&gt;本章将演示如何在本地电脑上利用IPV6服务，首先讲演示如何通过PPP验证获取IPV6地址（其他高校需要具体问题具体分析，仅供参考），接着在获取到可用的IPV6公网地址以后对纯IPV6访问方式作简单的介绍与演示。&lt;/p&gt;
&lt;h2 id=&quot;主要要求&quot;&gt;&lt;a href=&quot;#主要要求&quot; class=&quot;headerlink&quot; title=&quot;主要要求&quot;&gt;&lt;/a&gt;主要要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;装有Win7&amp;#x2F;Win8&amp;#x2F;Win10 系统的电脑一台&lt;/li&gt;
&lt;li&gt;网线&lt;/li&gt;
&lt;li&gt;对IPV6的基本应用有初步的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/categories/IPV6/"/>
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/tags/IPV6/"/>
    
  </entry>
  
  <entry>
    <title>V6资源介绍</title>
    <link href="http://blog.yinzi.me/post/v6resource/"/>
    <id>http://blog.yinzi.me/post/v6resource/</id>
    <published>2018-01-31T10:58:21.000Z</published>
    <updated>2026-01-11T14:08:13.966Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要整理一下博主目前所知道的支持纯V6访问的站点，不定期持续更新，欢迎各位补充~</p><blockquote><ul><li><a href="https://ipv6.google.com/">Google</a></li><li><a href="https://www.youtube.com/">Youtube</a></li><li><a href="https://www.facebook.com/">Facebook</a></li><li><a href="http://tv.byr.cn/">北邮人电视直播</a></li><li><a href="http://bt.neu6.edu.cn/">六维空间</a></li><li><a href="https://npupt.com/">蒲公英PT站</a></li><li><a href="http://pt.zhixing.bjtu.edu.cn/">北交知行PT站</a></li><li><a href="https://pt.sjtu.edu.cn/">上交葡萄PT站</a></li><li><a href="http://bt.byr.cn/">北邮人BT下载站</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇主要整理一下博主目前所知道的支持纯V6访问的站点，不定期持续更新，欢迎各位补充~&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ipv6.google.com/&quot;&gt;Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/categories/IPV6/"/>
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/tags/IPV6/"/>
    
  </entry>
  
  <entry>
    <title>了解IPV6</title>
    <link href="http://blog.yinzi.me/post/knowaboutipv6/"/>
    <id>http://blog.yinzi.me/post/knowaboutipv6/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2026-01-11T14:08:13.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPV6是什么"><a href="#IPV6是什么" class="headerlink" title="IPV6是什么"></a>IPV6是什么</h2><p>为了通过互联网进行通信，电脑和其他设备必须有发送者和接收者地址，<br>这些数字地址称为互联网协议地址也就是我们常说的IP地址，常见的IP地址分为<br>IPv4与IPv6两大类，其中IPV4地址就是我们平时所熟知的IP地址，<br>而IPV6则为网际协议第6版，是网际协议(IP)的最新版本。</p><span id="more"></span><h2 id="为什么要发展IPV6"><a href="#为什么要发展IPV6" class="headerlink" title="为什么要发展IPV6"></a>为什么要发展IPV6</h2><p>随着互联网的普及以及使用人数大幅增长，人们对IP<br>地址的需求也与日俱增。目前广泛采用的IPV4为32位地址，因此地址空间中只有4,294,967,296（$ 2^{32} $）个地址，况且这其中还会有<br>一些用于特殊用途的保留地址，如专用网络（约1800万个地址）和多播地址（约2.7亿个地址），这减少了可在互联网上路由的地址数量。<br>随着地址不断被分配给最终用户，IPv4地址枯竭问题也在随之产生。互联网工程任务组为了推迟这个问题的发生，推出了NAT和CIDR。但是这些过渡方案皆无法阻止地址枯竭问题的发生，只能减缓它的发生速度，最终的解决方案，仍然需要转换到IPv6。</p><p>IPV6采用128位地址，地址空间具有 $ 2ˆ{128} $<br>个地址，这个数字非常大，足以地球上每一粒沙子分配一个IPV6地址，由此从根本上解决了IP地址不够用的问题。</p><h2 id="关于IPV6的一些补充说明"><a href="#关于IPV6的一些补充说明" class="headerlink" title="关于IPV6的一些补充说明"></a>关于IPV6的一些补充说明</h2><blockquote><ul><li>IPV6不等于免费上网和高速上网</li></ul></blockquote><p>V6的PT资源下载站、不计费上网等相关内容和教程在网上到处都是，容易给不明情况的人造成一种误解，即IPV6技术就是一种高速网络、免费网络技术。<br>这都是不对的，所谓的高速下载和不计费，不过是因为国内V6的发展状况导致的临时现象罢了。</p><p>由于现在国内V6主要是用的人相对较少，<br>链路更加专用，所以速度自然就显得更快一些，<br>估计是因为受众小，很多部署V6的高校暂时懒得针对V6进行计费，所以才有所谓的免费上网。不过据说有些高校已经针对V6流量进行单独计费了,这点博主不大清楚，本文主要针对和博主学校目前的网络状况进行探讨。<br>更多的只是整理一下自己折腾的过程</p><blockquote><ul><li>严格来讲本集讨论的是6to4和4to6的各种实现过程</li></ul></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zh.wikipedia.org/wiki/IPv6">Wikipedia</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;IPV6是什么&quot;&gt;&lt;a href=&quot;#IPV6是什么&quot; class=&quot;headerlink&quot; title=&quot;IPV6是什么&quot;&gt;&lt;/a&gt;IPV6是什么&lt;/h2&gt;&lt;p&gt;为了通过互联网进行通信，电脑和其他设备必须有发送者和接收者地址，&lt;br&gt;这些数字地址称为互联网协议地址也就是我们常说的IP地址，常见的IP地址分为&lt;br&gt;IPv4与IPv6两大类，其中IPV4地址就是我们平时所熟知的IP地址，&lt;br&gt;而IPV6则为网际协议第6版，是网际协议(IP)的最新版本。&lt;/p&gt;</summary>
    
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/categories/IPV6/"/>
    
    
    <category term="IPV6" scheme="http://blog.yinzi.me/tags/IPV6/"/>
    
  </entry>
  
</feed>
